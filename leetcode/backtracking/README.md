
# 回溯法:evergreen_tree::evergreen_tree::evergreen_tree:

回溯法的本质：**穷举**，穷举出所有可能，然后保留最终需要的结果。穷举可以利用`循环`和`递归`来实现。使用回溯法，**一般而言可以将解题过程抽象为一棵有/无回路树的遍历。**



在后面的算法题中，**都要有意识地将题目抽象成一颗树:evergreen_tree:来处理**，树分为深度和宽度两个维度，我们使用两种方式来表示这两个维度：

- 深度：采用 **递归** 的方式，递归可以看成是层层深入，最终达到叶子结点。
- 宽度：采用 **循环** 的方式，循环可以看成是在树宽层面横向遍历，最终达到最右侧的边界结点。



![image-20231015101703476](https://cdn.jsdelivr.net/gh/ThousandLayerCake/picbed/image-20231015101703476.png)



**重点：**

**有意识地将题目抽象为树来处理，这是剪枝的关键所在！是算法性能提升的关键所在！一定要做**





## 回溯法效率

穷举，就注定它的性能不会很高，但是有些题目就是需要穷举才能做出结果，因此，**虽然这种方法比较暴力，但是可以通过合适的剪枝来提高时间复杂度**。









## 回溯法问题

一切可以 **抽象为树** 的问题。纵向树枝组成结果，横向树枝组成每次递归中循环的可能。

- 所有排列组合
- 所有子集子序列
- 棋盘问题：每个 **待确定的点** 组成一个列表，该列表本质上仍然是一个排列组合问题





## 回溯法做题思路

1. 将题目抽象为树，把树先画出来。
2. 根据模板确定函数参数，横向循环，纵向递归。
3. 确定去重的关键，考虑 **横向去重** 和 **纵向去重**。
   - 横向去重：一般是列表与列表的重复
   - 纵向去重：一般是列表内的元素重复
4. 将结果加入到 **结果列表**。
5. 判断是否结束，如果只有唯一答案可以提前结束。







## 回溯法模板

```python
### 
def main(self, nums):
    self.res = [] # 结果
    self.temp = [] # 收集可能的结果
    self.backtracking(参数)
    return self.res

def backtracking(self, 参数):
    if (终止条件):
        self.res.append(list(self.temp))
        return
    
    while (横向循环条件):
        self.temp.append(元素) 
        self.backtracking(参数) # 递归
        self.temp.pop() # 回溯
```



## 回溯法例题

- [组合问题合集](./combinations/README.md)
- [分割问题合集](./splits/README.md)
- [排列问题合集](./permutations/README.md)
- [HARD问题合集](./hards/README.md)
- [棋盘问题合集](./board/README.md)









